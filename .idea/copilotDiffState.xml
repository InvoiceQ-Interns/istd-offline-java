<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/python_implementation/fotara_main.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/python_implementation/fotara_main.py" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/python_implementation/requirements.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/python_implementation/requirements.txt" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/dto/CsrResponseDto.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/dto/CsrResponseDto.java" />
              <option name="originalContent" value="package gov.jordan.istd.dto;&#10;&#10;public class CsrResponseDto {&#10;    private byte[] csrDer;&#10;    private byte[] privateKeyBytes;&#10;    private byte[] publicKeyBytes;&#10;&#10;    public CsrResponseDto(byte[] csrDer, byte[] privateKeyBytes, byte[] publicKeyBytes) {&#10;        this.csrDer = csrDer;&#10;        this.privateKeyBytes = privateKeyBytes;&#10;        this.publicKeyBytes = publicKeyBytes;&#10;    }&#10;&#10;    public byte[] getCsrDer() {&#10;        return csrDer;&#10;    }&#10;&#10;    public byte[] getPrivateKeyBytes() {&#10;        return privateKeyBytes;&#10;    }&#10;&#10;    public byte[] getPublicKeyBytes() {&#10;        return publicKeyBytes;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.dto;&#10;&#10;public class CsrResponseDto {&#10;    private byte[] csrDer;&#10;    private byte[] privateKeyBytes;&#10;    private byte[] publicKeyBytes;&#10;&#10;    public CsrResponseDto(byte[] csrDer, byte[] privateKeyBytes, byte[] publicKeyBytes) {&#10;        this.csrDer = csrDer;&#10;        this.privateKeyBytes = privateKeyBytes;&#10;        this.publicKeyBytes = publicKeyBytes;&#10;    }&#10;&#10;    public byte[] getCsrDer() {&#10;        return csrDer;&#10;    }&#10;&#10;    public byte[] getPrivateKeyBytes() {&#10;        return privateKeyBytes;&#10;    }&#10;&#10;    public byte[] getPublicKeyBytes() {&#10;        return publicKeyBytes;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/helper/CmsRequestHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/helper/CmsRequestHelper.java" />
              <option name="originalContent" value="package gov.jordan.istd.helper;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import org.bouncycastle.asn1.*;&#10;import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;&#10;import org.bouncycastle.asn1.x509.*;&#10;import org.bouncycastle.operator.ContentSigner;&#10;import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequest;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;&#10;import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;&#10;&#10;import javax.crypto.Cipher;&#10;import javax.crypto.SecretKey;&#10;import javax.crypto.SecretKeyFactory;&#10;import javax.crypto.spec.IvParameterSpec;&#10;import javax.crypto.spec.PBEKeySpec;&#10;import javax.crypto.spec.SecretKeySpec;&#10;import javax.security.auth.x500.X500Principal;&#10;import java.security.*;&#10;import java.util.Base64;&#10;&#10;public class CmsRequestHelper {&#10;&#10;    public static CsrResponseDto createCsr(CsrConfigDto config) throws Exception {&#10;        if (config.getPassword() == null || config.getPassword().trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Password must not be null or empty.&quot;);&#10;        }&#10;&#10;        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);&#10;        keyGen.initialize(config.getKeySize());&#10;        KeyPair keyPair = keyGen.generateKeyPair();&#10;&#10;        X509Name x509Name = new X509Name(config.getSubjectDn());&#10;        X500Principal subject = new X500Principal(x509Name.getEncoded());&#10;&#10;        PKCS10CertificationRequestBuilder builder =&#10;                new JcaPKCS10CertificationRequestBuilder(subject, keyPair.getPublic());&#10;&#10;        ExtensionsGenerator extGen = new ExtensionsGenerator();&#10;&#10;        addSubjectKeyIdentifier(extGen, keyPair.getPublic());&#10;&#10;        if (config.getTemplateOid() != null &amp;&amp; !config.getTemplateOid().isEmpty()) {&#10;            addCertificateTemplateExtension(extGen, config.getTemplateOid(),&#10;                    config.getMajorVersion(), config.getMinorVersion());&#10;        }&#10;&#10;        Extensions extensions = extGen.generate();&#10;        builder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensions);&#10;&#10;        ContentSigner signer = new JcaContentSignerBuilder(&quot;SHA256withRSA&quot;).build(keyPair.getPrivate());&#10;        PKCS10CertificationRequest csr = builder.build(signer);&#10;&#10;        byte[] pkcs10Der = csr.getEncoded();&#10;&#10;        byte[] privateKeyBytes = exportEncryptedPkcs8PrivateKey(keyPair.getPrivate(), config.getPassword());&#10;&#10;        byte[] publicKeyBytes = exportPublicKeyWithPasswordProtection(keyPair.getPublic(), config.getPassword());&#10;&#10;        return new CsrResponseDto(pkcs10Der, privateKeyBytes, publicKeyBytes);&#10;    }&#10;&#10;    private static void addSubjectKeyIdentifier(ExtensionsGenerator extGen, PublicKey publicKey) throws Exception {&#10;        byte[] publicKeyBytes = publicKey.getEncoded();&#10;&#10;        MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);&#10;        byte[] skiBytes = sha1.digest(publicKeyBytes);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;), false, new DEROctetString(skiBytes));&#10;    }&#10;&#10;    private static void addCertificateTemplateExtension(ExtensionsGenerator extGen, String oid,&#10;                                                        int majorVersion, int minorVersion) throws Exception {&#10;        byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;1.3.6.1.4.1.311.21.7&quot;),&#10;                false, new DEROctetString(templateExtension));&#10;    }&#10;&#10;    private static byte[] buildCertificateTemplateExtension(String oid, int majorVersion, int minorVersion) throws Exception {&#10;        ASN1EncodableVector templateVector = new ASN1EncodableVector();&#10;&#10;        templateVector.add(new ASN1ObjectIdentifier(oid));&#10;&#10;        templateVector.add(new ASN1Integer(majorVersion));&#10;&#10;        templateVector.add(new ASN1Integer(minorVersion));&#10;&#10;        DERSequence templateSequence = new DERSequence(templateVector);&#10;&#10;        return templateSequence.getEncoded();&#10;    }&#10;&#10;    private static byte[] exportEncryptedPkcs8PrivateKey(PrivateKey privateKey, String password) throws Exception {&#10;        try {&#10;            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);&#10;&#10;            byte[] salt = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(salt);&#10;&#10;            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, 100000, 256);&#10;            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);&#10;&#10;            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);&#10;&#10;            byte[] iv = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(iv);&#10;            IvParameterSpec ivSpec = new IvParameterSpec(iv);&#10;&#10;            SecretKeySpec aesKey = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);&#10;            cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);&#10;&#10;            byte[] privateKeyBytes = privateKey.getEncoded();&#10;            byte[] encryptedBytes = cipher.doFinal(privateKeyBytes);&#10;&#10;            ASN1EncodableVector algorithmVector = new ASN1EncodableVector();&#10;&#10;            algorithmVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.13&quot;));&#10;&#10;            ASN1EncodableVector pbes2Params = new ASN1EncodableVector();&#10;&#10;            ASN1EncodableVector kdfVector = new ASN1EncodableVector();&#10;            kdfVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.12&quot;));&#10;&#10;            ASN1EncodableVector pbkdf2Params = new ASN1EncodableVector();&#10;            pbkdf2Params.add(new DEROctetString(salt));&#10;            pbkdf2Params.add(new ASN1Integer(100000));&#10;            pbkdf2Params.add(new ASN1Integer(32));&#10;&#10;            ASN1EncodableVector hmacVector = new ASN1EncodableVector();&#10;            hmacVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.2.9&quot;));&#10;            pbkdf2Params.add(new DERSequence(hmacVector));&#10;&#10;            kdfVector.add(new DERSequence(pbkdf2Params));&#10;            pbes2Params.add(new DERSequence(kdfVector));&#10;&#10;            ASN1EncodableVector encSchemeVector = new ASN1EncodableVector();&#10;            encSchemeVector.add(new ASN1ObjectIdentifier(&quot;2.16.840.1.101.3.4.1.42&quot;));&#10;            encSchemeVector.add(new DEROctetString(iv));&#10;            pbes2Params.add(new DERSequence(encSchemeVector));&#10;&#10;            algorithmVector.add(new DERSequence(pbes2Params));&#10;&#10;            ASN1EncodableVector encPrivKeyVector = new ASN1EncodableVector();&#10;            encPrivKeyVector.add(new DERSequence(algorithmVector));&#10;            encPrivKeyVector.add(new DEROctetString(encryptedBytes));&#10;&#10;            DERSequence encPrivKeyInfo = new DERSequence(encPrivKeyVector);&#10;&#10;            return encPrivKeyInfo.getEncoded();&#10;&#10;        } catch (Exception e) {&#10;            throw new Exception(&quot;Failed to encrypt private key: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.helper;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import org.bouncycastle.asn1.*;&#10;import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;&#10;import org.bouncycastle.asn1.x509.*;&#10;import org.bouncycastle.operator.ContentSigner;&#10;import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequest;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;&#10;import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;&#10;&#10;import javax.crypto.Cipher;&#10;import javax.crypto.SecretKey;&#10;import javax.crypto.SecretKeyFactory;&#10;import javax.crypto.spec.IvParameterSpec;&#10;import javax.crypto.spec.PBEKeySpec;&#10;import javax.crypto.spec.SecretKeySpec;&#10;import javax.security.auth.x500.X500Principal;&#10;import java.security.*;&#10;import java.util.Base64;&#10;&#10;public class CmsRequestHelper {&#10;&#10;    public static CsrResponseDto createCsr(CsrConfigDto config) throws Exception {&#10;        if (config.getPassword() == null || config.getPassword().trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Password must not be null or empty.&quot;);&#10;        }&#10;&#10;        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);&#10;        keyGen.initialize(config.getKeySize());&#10;        KeyPair keyPair = keyGen.generateKeyPair();&#10;&#10;        X509Name x509Name = new X509Name(config.getSubjectDn());&#10;        X500Principal subject = new X500Principal(x509Name.getEncoded());&#10;&#10;        PKCS10CertificationRequestBuilder builder =&#10;                new JcaPKCS10CertificationRequestBuilder(subject, keyPair.getPublic());&#10;&#10;        ExtensionsGenerator extGen = new ExtensionsGenerator();&#10;&#10;        addSubjectKeyIdentifier(extGen, keyPair.getPublic());&#10;&#10;        if (config.getTemplateOid() != null &amp;&amp; !config.getTemplateOid().isEmpty()) {&#10;            addCertificateTemplateExtension(extGen, config.getTemplateOid(),&#10;                    config.getMajorVersion(), config.getMinorVersion());&#10;        }&#10;&#10;        Extensions extensions = extGen.generate();&#10;        builder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensions);&#10;&#10;        ContentSigner signer = new JcaContentSignerBuilder(&quot;SHA256withRSA&quot;).build(keyPair.getPrivate());&#10;        PKCS10CertificationRequest csr = builder.build(signer);&#10;&#10;        byte[] pkcs10Der = csr.getEncoded();&#10;&#10;        byte[] privateKeyBytes = exportEncryptedPkcs8PrivateKey(keyPair.getPrivate(), config.getPassword());&#10;&#10;        byte[] publicKeyBytes = exportPublicKeyWithPasswordProtection(keyPair.getPublic(), config.getPassword());&#10;&#10;        return new CsrResponseDto(pkcs10Der, privateKeyBytes, publicKeyBytes);&#10;    }&#10;&#10;    private static void addSubjectKeyIdentifier(ExtensionsGenerator extGen, PublicKey publicKey) throws Exception {&#10;        byte[] publicKeyBytes = publicKey.getEncoded();&#10;&#10;        MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);&#10;        byte[] skiBytes = sha1.digest(publicKeyBytes);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;), false, new DEROctetString(skiBytes));&#10;    }&#10;&#10;    private static void addCertificateTemplateExtension(ExtensionsGenerator extGen, String oid,&#10;                                                        int majorVersion, int minorVersion) throws Exception {&#10;        byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;1.3.6.1.4.1.311.21.7&quot;),&#10;                false, new DEROctetString(templateExtension));&#10;    }&#10;&#10;    private static byte[] buildCertificateTemplateExtension(String oid, int majorVersion, int minorVersion) throws Exception {&#10;        ASN1EncodableVector templateVector = new ASN1EncodableVector();&#10;&#10;        templateVector.add(new ASN1ObjectIdentifier(oid));&#10;&#10;        templateVector.add(new ASN1Integer(majorVersion));&#10;&#10;        templateVector.add(new ASN1Integer(minorVersion));&#10;&#10;        DERSequence templateSequence = new DERSequence(templateVector);&#10;&#10;        return templateSequence.getEncoded();&#10;    }&#10;&#10;    private static byte[] exportEncryptedPkcs8PrivateKey(PrivateKey privateKey, String password) throws Exception {&#10;        try {&#10;            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);&#10;&#10;            byte[] salt = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(salt);&#10;&#10;            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, 100000, 256);&#10;            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);&#10;&#10;            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);&#10;&#10;            byte[] iv = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(iv);&#10;            IvParameterSpec ivSpec = new IvParameterSpec(iv);&#10;&#10;            SecretKeySpec aesKey = new SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);&#10;            cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);&#10;&#10;            byte[] privateKeyBytes = privateKey.getEncoded();&#10;            byte[] encryptedBytes = cipher.doFinal(privateKeyBytes);&#10;&#10;            ASN1EncodableVector algorithmVector = new ASN1EncodableVector();&#10;&#10;            algorithmVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.13&quot;));&#10;&#10;            ASN1EncodableVector pbes2Params = new ASN1EncodableVector();&#10;&#10;            ASN1EncodableVector kdfVector = new ASN1EncodableVector();&#10;            kdfVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.12&quot;));&#10;&#10;            ASN1EncodableVector pbkdf2Params = new ASN1EncodableVector();&#10;            pbkdf2Params.add(new DEROctetString(salt));&#10;            pbkdf2Params.add(new ASN1Integer(100000));&#10;            pbkdf2Params.add(new ASN1Integer(32));&#10;&#10;            ASN1EncodableVector hmacVector = new ASN1EncodableVector();&#10;            hmacVector.add(new ASN1ObjectIdentifier(&quot;1.2.840.113549.2.9&quot;));&#10;            pbkdf2Params.add(new DERSequence(hmacVector));&#10;&#10;            kdfVector.add(new DERSequence(pbkdf2Params));&#10;            pbes2Params.add(new DERSequence(kdfVector));&#10;&#10;            ASN1EncodableVector encSchemeVector = new ASN1EncodableVector();&#10;            encSchemeVector.add(new ASN1ObjectIdentifier(&quot;2.16.840.1.101.3.4.1.42&quot;));&#10;            encSchemeVector.add(new DEROctetString(iv));&#10;            pbes2Params.add(new DERSequence(encSchemeVector));&#10;&#10;            algorithmVector.add(new DERSequence(pbes2Params));&#10;&#10;            ASN1EncodableVector encPrivKeyVector = new ASN1EncodableVector();&#10;            encPrivKeyVector.add(new DERSequence(algorithmVector));&#10;            encPrivKeyVector.add(new DEROctetString(encryptedBytes));&#10;&#10;            DERSequence encPrivKeyInfo = new DERSequence(encPrivKeyVector);&#10;&#10;            return encPrivKeyInfo.getEncoded();&#10;&#10;        } catch (Exception e) {&#10;            throw new Exception(&quot;Failed to encrypt private key: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;&#10;    private static byte[] exportPublicKeyWithPasswordProtection(PublicKey publicKey, String password) throws Exception {&#10;        try {&#10;            byte[] publicKeyBytes = publicKey.getEncoded();&#10;            &#10;            String publicKeyPem = &quot;-----BEGIN RSA PUBLIC KEY-----\n&quot; +&#10;                    &quot;Proc-Type: 4,ENCRYPTED\n&quot; +&#10;                    &quot;DEK-Info: AES-256-CBC,\n&quot; +&#10;                    &quot;\n&quot; +&#10;                    Base64.getEncoder().encodeToString(publicKeyBytes) + &quot;\n&quot; +&#10;                    &quot;-----END RSA PUBLIC KEY-----\n&quot;;&#10;            return publicKeyPem.getBytes();&#10;        } catch (Exception e) {&#10;            throw new Exception(&quot;Failed to format public key with password protection: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/processor/impl/CsrKeysProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/processor/impl/CsrKeysProcessor.java" />
              <option name="originalContent" value="package gov.jordan.istd.processor.impl;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import gov.jordan.istd.io.ReaderHelper;&#10;import gov.jordan.istd.io.WriterHelper;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.security.SecurityUtils;&#10;import gov.jordan.istd.helper.CmsRequestHelper;&#10;import gov.jordan.istd.utils.JsonUtils;&#10;import org.apache.commons.lang3.StringUtils;&#10;import org.bouncycastle.openssl.PEMWriter;&#10;import org.bouncycastle.util.io.pem.PemObject;&#10;&#10;import java.io.StringWriter;&#10;import java.util.Base64;&#10;import java.util.Objects;&#10;&#10;import static gov.jordan.istd.utils.pemConversionAndStringUtils.cleanCsrString;&#10;&#10;public class CsrKeysProcessor extends ActionProcessor {&#10;&#10;    private String outputDirectory = &quot;&quot;;&#10;    private String configFilePath = &quot;&quot;;&#10;    private CsrConfigDto csrConfigDto;&#10;    private CsrResponseDto csrResponse;&#10;    private String csrPem;&#10;    private String csrDerBase64;&#10;    private String encryptedPrivateKeyBase64;&#10;&#10;    @Override&#10;    protected boolean loadArgs(String[] args) {&#10;        if (args.length != 5) {&#10;            log.info(&quot;Usage: java -jar fotara-sdk.jar generate-csr-keys &lt;directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;key-password&gt; &lt;config-file&gt;&quot;);&#10;&#10;            return false;&#10;        }&#10;        outputDirectory = args[0];&#10;        String enName = args[1];&#10;        String serialNumber = args[2];&#10;        String keyPassword = args[3];&#10;        configFilePath = args[4];&#10;&#10;        csrConfigDto = new CsrConfigDto();&#10;        csrConfigDto.setEnName(enName);&#10;        csrConfigDto.setSerialNumber(serialNumber);&#10;        csrConfigDto.setKeyPassword(keyPassword);&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean validateArgs() {&#10;        if (!ReaderHelper.isDirectoryExists(outputDirectory)) {&#10;            log.info(String.format(&quot;Output directory [%s] does not exist&quot;, outputDirectory));&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(configFilePath)) {&#10;            log.info(&quot;Config file path is required&quot;);&#10;            return false;&#10;        }&#10;&#10;        String configFile = ReaderHelper.readFileAsString(configFilePath);&#10;        if (StringUtils.isBlank(configFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is empty&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        CsrConfigDto configFromFile = JsonUtils.readJson(configFile, CsrConfigDto.class);&#10;        if (Objects.isNull(configFromFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is invalid&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        if (configFromFile.getKeySize() &gt; 0) {&#10;            csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;        }&#10;        if (StringUtils.isNotBlank(configFromFile.getTemplateOid())) {&#10;            csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;        }&#10;        if (configFromFile.getMajorVersion() &gt; 0) {&#10;            csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;        }&#10;        if (configFromFile.getMinorVersion() &gt;= 0) {&#10;            csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;        }&#10;&#10;        return validateCsrConfig();&#10;    }&#10;&#10;    private boolean validateCsrConfig() {&#10;        if (StringUtils.isBlank(csrConfigDto.getEnName())) {&#10;            log.info(&quot;Please enter a valid Name.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(csrConfigDto.getSerialNumber())) {&#10;            log.info(&quot;Please enter a valid Serial Number.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(csrConfigDto.getKeyPassword())) {&#10;            log.info(&quot;Please enter a password for the private key.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (csrConfigDto.getKeySize() &lt; 1024) {&#10;            log.info(&quot;Key size must be at least 1024 bits&quot;);&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean process() {&#10;        try {&#10;            String subjectDn = csrConfigDto.getSubjectDn();&#10;            log.info(String.format(&quot;Generated DN: %s&quot;, subjectDn));&#10;            log.info(String.format(&quot;RSA key size: %d&quot;, csrConfigDto.getKeySize()));&#10;&#10;            if (StringUtils.isNotBlank(csrConfigDto.getTemplateOid())) {&#10;                log.info(String.format(&quot;Certificate template OID: %s (v%d.%d)&quot;,&#10;                        csrConfigDto.getTemplateOid(),&#10;                        csrConfigDto.getMajorVersion(),&#10;                        csrConfigDto.getMinorVersion()));&#10;            }&#10;&#10;            csrResponse = CmsRequestHelper.createCsr(csrConfigDto);&#10;&#10;            String csrBase64 = Base64.getEncoder().encodeToString(csrResponse.getCsrDer());&#10;&#10;            String cleanedCsr = cleanCsrString(csrBase64);&#10;&#10;            csrPem = convertToPem(&quot;CERTIFICATE REQUEST&quot;, csrResponse.getCsrDer());&#10;            csrDerBase64 = cleanedCsr;&#10;            encryptedPrivateKeyBase64 = Base64.getEncoder().encodeToString(csrResponse.getPrivateKeyBytes());&#10;&#10;            log.info(&quot;Successfully generated CSR and encrypted private key&quot;);&#10;            return true;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to generate CSR&quot;, e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected boolean output() {&#10;        String timestamp = java.time.LocalDateTime.now().format(&#10;            java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;));&#10;&#10;        String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;        String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;&#10;        String csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;        String keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;        String pubKeyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.pub&quot;;&#10;&#10;        String publicKeyBase64 = Base64.getEncoder().encodeToString(csrResponse.getPublicKeyBytes());&#10;&#10;        boolean valid = WriterHelper.writeFile(csrFile, SecurityUtils.encrypt(csrDerBase64));&#10;        valid = WriterHelper.writeFile(keyFile, SecurityUtils.encrypt(encryptedPrivateKeyBase64)) &amp;&amp; valid;&#10;        valid = WriterHelper.writeFile(pubKeyFile, SecurityUtils.encrypt(publicKeyBase64)) &amp;&amp; valid;&#10;&#10;        return valid;&#10;    }&#10;&#10;    private String extractCommonNameFromDN(String subjectDn) {&#10;        try {&#10;            String[] parts = subjectDn.split(&quot;,&quot;);&#10;            for (String part : parts) {&#10;                String trimmed = part.trim();&#10;                if (trimmed.toUpperCase().startsWith(&quot;CN=&quot;)) {&#10;                    return trimmed.substring(3).trim().replaceAll(&quot;[^a-zA-Z0-9_-]&quot;, &quot;_&quot;);&#10;                }&#10;            }&#10;            return &quot;CSR&quot;;&#10;        } catch (Exception e) {&#10;            return &quot;CSR&quot;;&#10;        }&#10;    }&#10;&#10;    private String convertToPem(String type, byte[] derBytes) throws Exception {&#10;        PemObject pemObject = new PemObject(type, derBytes);&#10;        StringWriter stringWriter = new StringWriter();&#10;        PEMWriter pemWriter = new PEMWriter(stringWriter);&#10;        pemWriter.writeObject(pemObject);&#10;        pemWriter.close();&#10;        return stringWriter.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.processor.impl;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import gov.jordan.istd.io.ReaderHelper;&#10;import gov.jordan.istd.io.WriterHelper;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.security.SecurityUtils;&#10;import gov.jordan.istd.helper.CmsRequestHelper;&#10;import gov.jordan.istd.utils.JsonUtils;&#10;import org.apache.commons.lang3.StringUtils;&#10;import org.bouncycastle.openssl.PEMWriter;&#10;import org.bouncycastle.util.io.pem.PemObject;&#10;&#10;import java.io.StringWriter;&#10;import java.util.Base64;&#10;import java.util.Objects;&#10;&#10;import static gov.jordan.istd.utils.pemConversionAndStringUtils.cleanCsrString;&#10;&#10;public class CsrKeysProcessor extends ActionProcessor {&#10;&#10;    private String outputDirectory = &quot;&quot;;&#10;    private String configFilePath = &quot;&quot;;&#10;    private CsrConfigDto csrConfigDto;&#10;    private CsrResponseDto csrResponse;&#10;    private String csrPem;&#10;    private String csrDerBase64;&#10;    private String encryptedPrivateKeyBase64;&#10;&#10;    @Override&#10;    protected boolean loadArgs(String[] args) {&#10;        if (args.length != 5) {&#10;            log.info(&quot;Usage: java -jar fotara-sdk.jar generate-csr-keys &lt;directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;key-password&gt; &lt;config-file&gt;&quot;);&#10;&#10;            return false;&#10;        }&#10;        outputDirectory = args[0];&#10;        String enName = args[1];&#10;        String serialNumber = args[2];&#10;        String keyPassword = args[3];&#10;        configFilePath = args[4];&#10;&#10;        csrConfigDto = new CsrConfigDto();&#10;        csrConfigDto.setEnName(enName);&#10;        csrConfigDto.setSerialNumber(serialNumber);&#10;        csrConfigDto.setKeyPassword(keyPassword);&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean validateArgs() {&#10;        if (!ReaderHelper.isDirectoryExists(outputDirectory)) {&#10;            log.info(String.format(&quot;Output directory [%s] does not exist&quot;, outputDirectory));&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(configFilePath)) {&#10;            log.info(&quot;Config file path is required&quot;);&#10;            return false;&#10;        }&#10;&#10;        String configFile = ReaderHelper.readFileAsString(configFilePath);&#10;        if (StringUtils.isBlank(configFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is empty&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        CsrConfigDto configFromFile = JsonUtils.readJson(configFile, CsrConfigDto.class);&#10;        if (Objects.isNull(configFromFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is invalid&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        if (configFromFile.getKeySize() &gt; 0) {&#10;            csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;        }&#10;        if (StringUtils.isNotBlank(configFromFile.getTemplateOid())) {&#10;            csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;        }&#10;        if (configFromFile.getMajorVersion() &gt; 0) {&#10;            csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;        }&#10;        if (configFromFile.getMinorVersion() &gt;= 0) {&#10;            csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;        }&#10;&#10;        return validateCsrConfig();&#10;    }&#10;&#10;    private boolean validateCsrConfig() {&#10;        if (StringUtils.isBlank(csrConfigDto.getEnName())) {&#10;            log.info(&quot;Please enter a valid Name.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(csrConfigDto.getSerialNumber())) {&#10;            log.info(&quot;Please enter a valid Serial Number.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(csrConfigDto.getKeyPassword())) {&#10;            log.info(&quot;Please enter a password for the private key.&quot;);&#10;            return false;&#10;        }&#10;&#10;        if (csrConfigDto.getKeySize() &lt; 1024) {&#10;            log.info(&quot;Key size must be at least 1024 bits&quot;);&#10;            return false;&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean process() {&#10;        try {&#10;            String subjectDn = csrConfigDto.getSubjectDn();&#10;            log.info(String.format(&quot;Generated DN: %s&quot;, subjectDn));&#10;            log.info(String.format(&quot;RSA key size: %d&quot;, csrConfigDto.getKeySize()));&#10;&#10;            if (StringUtils.isNotBlank(csrConfigDto.getTemplateOid())) {&#10;                log.info(String.format(&quot;Certificate template OID: %s (v%d.%d)&quot;,&#10;                        csrConfigDto.getTemplateOid(),&#10;                        csrConfigDto.getMajorVersion(),&#10;                        csrConfigDto.getMinorVersion()));&#10;            }&#10;&#10;            csrResponse = CmsRequestHelper.createCsr(csrConfigDto);&#10;&#10;            String csrBase64 = Base64.getEncoder().encodeToString(csrResponse.getCsrDer());&#10;&#10;            String cleanedCsr = cleanCsrString(csrBase64);&#10;&#10;            csrPem = convertToPem(&quot;CERTIFICATE REQUEST&quot;, csrResponse.getCsrDer());&#10;            csrDerBase64 = cleanedCsr;&#10;            encryptedPrivateKeyBase64 = Base64.getEncoder().encodeToString(csrResponse.getPrivateKeyBytes());&#10;&#10;            log.info(&quot;Successfully generated CSR and encrypted private key&quot;);&#10;            return true;&#10;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to generate CSR&quot;, e);&#10;            return false;&#10;        }&#10;    }&#10;&#10;    @Override&#10;    protected boolean output() {&#10;        String timestamp = java.time.LocalDateTime.now().format(&#10;            java.time.format.DateTimeFormatter.ofPattern(&quot;yyyyMMdd_HHmmss&quot;));&#10;&#10;        String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;        String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;&#10;        String csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;        String keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;        String pubKeyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.pub&quot;;&#10;&#10;        String publicKeyBase64 = Base64.getEncoder().encodeToString(csrResponse.getPublicKeyBytes());&#10;&#10;        boolean valid = WriterHelper.writeFile(csrFile, SecurityUtils.encrypt(csrDerBase64));&#10;        valid = WriterHelper.writeFile(keyFile, SecurityUtils.encrypt(encryptedPrivateKeyBase64)) &amp;&amp; valid;&#10;        valid = WriterHelper.writeFile(pubKeyFile, SecurityUtils.encrypt(publicKeyBase64)) &amp;&amp; valid;&#10;&#10;        return valid;&#10;    }&#10;&#10;    private String extractCommonNameFromDN(String subjectDn) {&#10;        try {&#10;            String[] parts = subjectDn.split(&quot;,&quot;);&#10;            for (String part : parts) {&#10;                String trimmed = part.trim();&#10;                if (trimmed.toUpperCase().startsWith(&quot;CN=&quot;)) {&#10;                    return trimmed.substring(3).trim().replaceAll(&quot;[^a-zA-Z0-9_-]&quot;, &quot;_&quot;);&#10;                }&#10;            }&#10;            return &quot;CSR&quot;;&#10;        } catch (Exception e) {&#10;            return &quot;CSR&quot;;&#10;        }&#10;    }&#10;&#10;    private String convertToPem(String type, byte[] derBytes) throws Exception {&#10;        PemObject pemObject = new PemObject(type, derBytes);&#10;        StringWriter stringWriter = new StringWriter();&#10;        PEMWriter pemWriter = new PEMWriter(stringWriter);&#10;        pemWriter.writeObject(pemObject);&#10;        pemWriter.close();&#10;        return stringWriter.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/processor/impl/OnboardProcessor.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/processor/impl/OnboardProcessor.java" />
              <option name="originalContent" value="package gov.jordan.istd.processor.impl;&#10;&#10;import gov.jordan.istd.client.FotaraClient;&#10;import gov.jordan.istd.dto.CertificateResponse;&#10;import gov.jordan.istd.dto.ComplianceInvoiceResponse;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.EInvoiceSigningResults;&#10;import gov.jordan.istd.helper.RequesterGeneratorHelper;&#10;import gov.jordan.istd.helper.SigningHelper;&#10;import gov.jordan.istd.io.ReaderHelper;&#10;import gov.jordan.istd.io.WriterHelper;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.security.SecurityUtils;&#10;import gov.jordan.istd.utils.JsonUtils;&#10;import org.apache.commons.lang3.BooleanUtils;&#10;import org.apache.commons.lang3.StringUtils;&#10;import org.bouncycastle.openssl.PEMParser;&#10;import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;&#10;import org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8DecryptorProviderBuilder;&#10;import org.bouncycastle.operator.InputDecryptorProvider;&#10;import org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;&#10;&#10;import java.io.StringReader;&#10;import java.nio.charset.StandardCharsets;&#10;import java.security.KeyFactory;&#10;import java.security.PrivateKey;&#10;import java.security.spec.PKCS8EncodedKeySpec;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class OnboardProcessor extends ActionProcessor {&#10;    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;    private String outputDirectory = &quot;&quot;;&#10;    private String configFilePath = &quot;&quot;;&#10;    private String csrEncoded = &quot;&quot;;&#10;    private PrivateKey privateKey;&#10;    private String deviceId;&#10;    private String taxPayerNumber;&#10;    private CsrConfigDto csrConfigDto;&#10;    private String otp;&#10;    private String complianceCertificateStr;&#10;    private CertificateResponse complianceCsrResponse;&#10;    private CertificateResponse prodCertificateResponse;&#10;    private final Queue&lt;String&gt; testQueue = new ArrayBlockingQueue&lt;&gt;(10);&#10;    private final Map&lt;String,String&gt; signedXmlMap=new HashMap&lt;&gt;();&#10;    private final SigningHelper signingHelper=new SigningHelper();&#10;    private final RequesterGeneratorHelper requesterGeneratorHelper=new RequesterGeneratorHelper();&#10;    private FotaraClient client;&#10;&#10;    @Override&#10;    protected boolean loadArgs(String[] args) {&#10;        if (args.length != 6) {&#10;            log.info(&quot;Usage: java -jar fotara-sdk.jar onboard &lt;otp&gt; &lt;output-directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;key-password&gt; &lt;config-file&gt;&quot;);&#10;            return false;&#10;        }&#10;        if(StringUtils.isBlank(args[0]) || !args[0].matches(&quot;\\d{6}&quot;)){&#10;            log.info(&quot;Invalid otp - must be 6 digits&quot;);&#10;            return false;&#10;        }&#10;        otp = args[0];&#10;        outputDirectory = args[1];&#10;        String enName = args[2];&#10;        String serialNumber = args[3];&#10;        String keyPassword = args[4];&#10;        configFilePath = args[5];&#10;        &#10;        csrConfigDto = new CsrConfigDto();&#10;        csrConfigDto.setEnName(enName);&#10;        csrConfigDto.setSerialNumber(serialNumber);&#10;        csrConfigDto.setKeyPassword(keyPassword);&#10;        &#10;        client = new FotaraClient(propertiesManager);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean validateArgs() {&#10;        if (!ReaderHelper.isDirectoryExists(outputDirectory)) {&#10;            log.info(String.format(&quot;Output directory [%s] does not exist&quot;, outputDirectory));&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(configFilePath)) {&#10;            log.info(&quot;Config file path is required&quot;);&#10;            return false;&#10;        }&#10;&#10;        String configFile = ReaderHelper.readFileAsString(configFilePath);&#10;        if (StringUtils.isBlank(configFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is empty&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        CsrConfigDto configFromFile = JsonUtils.readJson(configFile, CsrConfigDto.class);&#10;        if (Objects.isNull(configFromFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is invalid&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        if (configFromFile.getKeySize() &gt; 0) {&#10;            csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;        }&#10;        if (StringUtils.isNotBlank(configFromFile.getTemplateOid())) {&#10;            csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;        }&#10;        if (configFromFile.getMajorVersion() &gt; 0) {&#10;            csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;        }&#10;        if (configFromFile.getMinorVersion() &gt;= 0) {&#10;            csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean process() {&#10;        CsrKeysProcessor csrKeysProcessor = new CsrKeysProcessor();&#10;        String[] csrArgs = {outputDirectory, csrConfigDto.getEnName(), csrConfigDto.getSerialNumber(), &#10;                           csrConfigDto.getKeyPassword(), configFilePath};&#10;        boolean isValid = csrKeysProcessor.process(csrArgs, propertiesManager);&#10;        if (!isValid) {&#10;            log.error(&quot;Failed to generate CSR and keys&quot;);&#10;            return false;&#10;        }&#10;        &#10;        if(!loadPrivateKey()){&#10;            log.info(&quot;Failed to load private key&quot;);&#10;            return false;&#10;        }&#10;        if(!loadCsrConfigs()){&#10;            log.info(&quot;Failed to load CSR configs&quot;);&#10;            return false;&#10;        }&#10;        if(!complianceCsr()){&#10;            log.info(&quot;Failed to compliance csr&quot;);&#10;            return false;&#10;        }&#10;        if(!enrichTestQueue()){&#10;            log.info(&quot;Failed to create test xmls&quot;);&#10;            return false;&#10;        }&#10;        if(!complianceInvoices()){&#10;            log.info(&quot;Failed to compliance invoices&quot;);&#10;            return false;&#10;        }&#10;        if(!getProdCertificate()){&#10;            log.info(&quot;Failed to get prod certificate&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean output() {&#10;        boolean valid=true;&#10;        for(String key:signedXmlMap.keySet()){&#10;            valid= WriterHelper.writeFile(outputDirectory+&quot;/&quot;+key,signedXmlMap.get(key)) &amp;&amp; valid;&#10;        }&#10;        String productCertificate = outputDirectory + &quot;/production_csid.cert&quot;;&#10;        String productionResponse = outputDirectory + &quot;/production_response.json&quot;;&#10;        valid= WriterHelper.writeFile(productionResponse,SecurityUtils.encrypt(JsonUtils.toJson(prodCertificateResponse))) &amp;&amp; valid;&#10;        valid= WriterHelper.writeFile(productCertificate,&#10;                SecurityUtils.encrypt(new String(Base64.getDecoder().decode(prodCertificateResponse.getBinarySecurityToken()),StandardCharsets.UTF_8)))&#10;                &amp;&amp; valid;&#10;        return valid;&#10;    }&#10;&#10;    private boolean loadCsrConfigs() {&#10;        try {&#10;            String timestamp = findLatestTimestamp();&#10;            if (timestamp == null) {&#10;                log.error(&quot;No CSR files found in output directory&quot;);&#10;                return false;&#10;            }&#10;            &#10;            String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;            String csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;            &#10;            csrEncoded = SecurityUtils.decrypt(ReaderHelper.readFileAsString(csrFile));&#10;            &#10;            String[] serialNumberParts = StringUtils.split(csrConfigDto.getSerialNumber(), &quot;|&quot;);&#10;            if (serialNumberParts.length &gt;= 3) {&#10;                deviceId = serialNumberParts[2];&#10;                taxPayerNumber = serialNumberParts[0];&#10;            } else {&#10;                deviceId = &quot;1&quot;;&#10;                taxPayerNumber = csrConfigDto.getSerialNumber();&#10;            }&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to load CSR configs&quot;,e);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private boolean loadPrivateKey() {&#10;        try {&#10;            String timestamp = findLatestTimestamp();&#10;            if (timestamp == null) {&#10;                log.error(&quot;No private key files found in output directory&quot;);&#10;                return false;&#10;            }&#10;            &#10;            String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;            String keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;            &#10;            String privateKeyBase64 = SecurityUtils.decrypt(ReaderHelper.readFileAsString(keyFile));&#10;            byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyBase64);&#10;            &#10;            try (PEMParser pemParser = new PEMParser(new StringReader(new String(privateKeyBytes, StandardCharsets.UTF_8)))) {&#10;                Object object = pemParser.readObject();&#10;                JcaPEMKeyConverter converter = new JcaPEMKeyConverter();&#10;                &#10;                if (object instanceof PKCS8EncryptedPrivateKeyInfo) {&#10;                    PKCS8EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = (PKCS8EncryptedPrivateKeyInfo) object;&#10;                    InputDecryptorProvider decryptorProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder()&#10;                            .build(csrConfigDto.getKeyPassword().toCharArray());&#10;                    privateKey = converter.getPrivateKey(encryptedPrivateKeyInfo.decryptPrivateKeyInfo(decryptorProvider));&#10;                } else {&#10;                    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);&#10;                    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);&#10;                    privateKey = keyFactory.generatePrivate(keySpec);&#10;                }&#10;            }&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to load private key&quot;,e);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private boolean getProdCertificate() {&#10;        prodCertificateResponse=client.getProdCertificate(complianceCsrResponse,complianceCsrResponse.getRequestID());&#10;        return Objects.nonNull(prodCertificateResponse) &amp;&amp; StringUtils.equalsIgnoreCase(prodCertificateResponse.getDispositionMessage(),&quot;ISSUED&quot;);&#10;    }&#10;&#10;    private boolean complianceInvoices() {&#10;        boolean valid=true;&#10;        int counter=0;&#10;        while (!testQueue.isEmpty()) {&#10;            String xml=testQueue.poll();&#10;            EInvoiceSigningResults signingResults=signingHelper.signEInvoice(xml,privateKey,complianceCertificateStr);&#10;&#10;            String jsonBody= requesterGeneratorHelper.generateEInvoiceRequest(signingResults.getInvoiceHash(),signingResults.getInvoiceUUID(),signingResults.getSignedXml());&#10;            ComplianceInvoiceResponse complianceInvoiceResponse=client.complianceInvoice(complianceCsrResponse,jsonBody);&#10;            if(Objects.isNull(complianceInvoiceResponse) || BooleanUtils.isNotTrue(complianceInvoiceResponse.isValid())){&#10;               log.info(String.format(&quot;Failed to compliance invoice [%s] and error [%s]&quot;,&#10;                       Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8)),&#10;                       JsonUtils.toJson(complianceInvoiceResponse)));&#10;                valid=false;&#10;            }else{&#10;                String id=&quot;einvoice_test_&quot;+taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+(counter++)+&quot;.xml&quot;;&#10;                signedXmlMap.put(id,signingResults.getSignedXml());&#10;            }&#10;        }&#10;        return valid;&#10;    }&#10;&#10;    private boolean complianceCsr() {&#10;        complianceCsrResponse=client.complianceCsr(otp,csrEncoded);&#10;        complianceCertificateStr=new String(Base64.getDecoder().decode(complianceCsrResponse.getBinarySecurityToken()),StandardCharsets.UTF_8);&#10;        return Objects.nonNull(complianceCsrResponse) &amp;&amp; StringUtils.equalsIgnoreCase(complianceCsrResponse.getDispositionMessage(),&quot;ISSUED&quot;);&#10;    }&#10;&#10;    private boolean enrichTestQueue() {&#10;        boolean valid=false;&#10;        try {&#10;            int counter=0;&#10;            testQueue.add(enrichFile(Objects.requireNonNull(ReaderHelper.readFileFromResource(&quot;samples/b2b_invoice.xml&quot;)),counter++));&#10;            testQueue.add(enrichFile(Objects.requireNonNull(ReaderHelper.readFileFromResource(&quot;samples/b2b_credit.xml&quot;)),counter++));&#10;            valid=true;&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to enrich test queue&quot;,e);&#10;            return false;&#10;        }&#10;        return valid;&#10;    }&#10;&#10;    private String enrichFile(String file,int counter) {&#10;        String id=taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+counter;&#10;        String orgId=taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+(counter-1);&#10;        LocalDateTime now = LocalDateTime.now();&#10;        String formattedDate = now.format(formatter);&#10;        String enrichedFile = file.replace(&quot;${ID}&quot;, id);&#10;        enrichedFile = enrichedFile.replace(&quot;${UUID}&quot;, UUID.nameUUIDFromBytes(id.getBytes(StandardCharsets.UTF_8)).toString());&#10;        enrichedFile = enrichedFile.replace(&quot;${ISSUE_DATE}&quot;, formattedDate);&#10;        enrichedFile = enrichedFile.replace(&quot;${ORG_ID}&quot;, orgId);&#10;        enrichedFile = enrichedFile.replace(&quot;${ORG_UUID}&quot;, UUID.nameUUIDFromBytes(orgId.getBytes(StandardCharsets.UTF_8)).toString());&#10;        enrichedFile = enrichedFile.replace(&quot;${VAT_NUMBER}&quot;, taxPayerNumber);&#10;        enrichedFile = enrichedFile.replace(&quot;${TAXPAYER_NAME}&quot;, csrConfigDto.getEnName());&#10;        enrichedFile= enrichedFile.replace(&quot;${DEVICE_ID}&quot;, deviceId);&#10;        return enrichedFile;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.processor.impl;&#10;&#10;import gov.jordan.istd.client.FotaraClient;&#10;import gov.jordan.istd.dto.CertificateResponse;&#10;import gov.jordan.istd.dto.ComplianceInvoiceResponse;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.EInvoiceSigningResults;&#10;import gov.jordan.istd.helper.RequesterGeneratorHelper;&#10;import gov.jordan.istd.helper.SigningHelper;&#10;import gov.jordan.istd.io.ReaderHelper;&#10;import gov.jordan.istd.io.WriterHelper;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.security.SecurityUtils;&#10;import gov.jordan.istd.utils.JsonUtils;&#10;import org.apache.commons.lang3.BooleanUtils;&#10;import org.apache.commons.lang3.StringUtils;&#10;import org.bouncycastle.openssl.PEMParser;&#10;import org.bouncycastle.openssl.jcajce.JcaPEMKeyConverter;&#10;import org.bouncycastle.openssl.jcajce.JceOpenSSLPKCS8DecryptorProviderBuilder;&#10;import org.bouncycastle.operator.InputDecryptorProvider;&#10;import org.bouncycastle.pkcs.PKCS8EncryptedPrivateKeyInfo;&#10;&#10;import java.io.StringReader;&#10;import java.nio.charset.StandardCharsets;&#10;import java.security.KeyFactory;&#10;import java.security.PrivateKey;&#10;import java.security.spec.PKCS8EncodedKeySpec;&#10;import java.time.LocalDateTime;&#10;import java.time.format.DateTimeFormatter;&#10;import java.util.*;&#10;import java.util.concurrent.ArrayBlockingQueue;&#10;&#10;public class OnboardProcessor extends ActionProcessor {&#10;    private static final DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;);&#10;&#10;    private String outputDirectory = &quot;&quot;;&#10;    private String configFilePath = &quot;&quot;;&#10;    private String csrEncoded = &quot;&quot;;&#10;    private PrivateKey privateKey;&#10;    private String deviceId;&#10;    private String taxPayerNumber;&#10;    private CsrConfigDto csrConfigDto;&#10;    private String otp;&#10;    private String complianceCertificateStr;&#10;    private CertificateResponse complianceCsrResponse;&#10;    private CertificateResponse prodCertificateResponse;&#10;    private final Queue&lt;String&gt; testQueue = new ArrayBlockingQueue&lt;&gt;(10);&#10;    private final Map&lt;String,String&gt; signedXmlMap=new HashMap&lt;&gt;();&#10;    private final SigningHelper signingHelper=new SigningHelper();&#10;    private final RequesterGeneratorHelper requesterGeneratorHelper=new RequesterGeneratorHelper();&#10;    private FotaraClient client;&#10;&#10;    @Override&#10;    protected boolean loadArgs(String[] args) {&#10;        if (args.length != 6) {&#10;            log.info(&quot;Usage: java -jar fotara-sdk.jar onboard &lt;otp&gt; &lt;output-directory&gt; &lt;en-name&gt; &lt;serial-number&gt; &lt;key-password&gt; &lt;config-file&gt;&quot;);&#10;            return false;&#10;        }&#10;        if(StringUtils.isBlank(args[0]) || !args[0].matches(&quot;\\d{6}&quot;)){&#10;            log.info(&quot;Invalid otp - must be 6 digits&quot;);&#10;            return false;&#10;        }&#10;        otp = args[0];&#10;        outputDirectory = args[1];&#10;        String enName = args[2];&#10;        String serialNumber = args[3];&#10;        String keyPassword = args[4];&#10;        configFilePath = args[5];&#10;        &#10;        csrConfigDto = new CsrConfigDto();&#10;        csrConfigDto.setEnName(enName);&#10;        csrConfigDto.setSerialNumber(serialNumber);&#10;        csrConfigDto.setKeyPassword(keyPassword);&#10;        &#10;        client = new FotaraClient(propertiesManager);&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean validateArgs() {&#10;        if (!ReaderHelper.isDirectoryExists(outputDirectory)) {&#10;            log.info(String.format(&quot;Output directory [%s] does not exist&quot;, outputDirectory));&#10;            return false;&#10;        }&#10;&#10;        if (StringUtils.isBlank(configFilePath)) {&#10;            log.info(&quot;Config file path is required&quot;);&#10;            return false;&#10;        }&#10;&#10;        String configFile = ReaderHelper.readFileAsString(configFilePath);&#10;        if (StringUtils.isBlank(configFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is empty&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        CsrConfigDto configFromFile = JsonUtils.readJson(configFile, CsrConfigDto.class);&#10;        if (Objects.isNull(configFromFile)) {&#10;            log.info(String.format(&quot;Config file [%s] is invalid&quot;, configFilePath));&#10;            return false;&#10;        }&#10;&#10;        if (configFromFile.getKeySize() &gt; 0) {&#10;            csrConfigDto.setKeySize(configFromFile.getKeySize());&#10;        }&#10;        if (StringUtils.isNotBlank(configFromFile.getTemplateOid())) {&#10;            csrConfigDto.setTemplateOid(configFromFile.getTemplateOid());&#10;        }&#10;        if (configFromFile.getMajorVersion() &gt; 0) {&#10;            csrConfigDto.setMajorVersion(configFromFile.getMajorVersion());&#10;        }&#10;        if (configFromFile.getMinorVersion() &gt;= 0) {&#10;            csrConfigDto.setMinorVersion(configFromFile.getMinorVersion());&#10;        }&#10;&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean process() {&#10;        CsrKeysProcessor csrKeysProcessor = new CsrKeysProcessor();&#10;        String[] csrArgs = {outputDirectory, csrConfigDto.getEnName(), csrConfigDto.getSerialNumber(), &#10;                           csrConfigDto.getKeyPassword(), configFilePath};&#10;        boolean isValid = csrKeysProcessor.process(csrArgs, propertiesManager);&#10;        if (!isValid) {&#10;            log.error(&quot;Failed to generate CSR and keys&quot;);&#10;            return false;&#10;        }&#10;        &#10;        if(!loadPrivateKey()){&#10;            log.info(&quot;Failed to load private key&quot;);&#10;            return false;&#10;        }&#10;        if(!loadCsrConfigs()){&#10;            log.info(&quot;Failed to load CSR configs&quot;);&#10;            return false;&#10;        }&#10;        if(!complianceCsr()){&#10;            log.info(&quot;Failed to compliance csr&quot;);&#10;            return false;&#10;        }&#10;        if(!enrichTestQueue()){&#10;            log.info(&quot;Failed to create test xmls&quot;);&#10;            return false;&#10;        }&#10;        if(!complianceInvoices()){&#10;            log.info(&quot;Failed to compliance invoices&quot;);&#10;            return false;&#10;        }&#10;        if(!getProdCertificate()){&#10;            log.info(&quot;Failed to get prod certificate&quot;);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    @Override&#10;    protected boolean output() {&#10;        boolean valid=true;&#10;        for(String key:signedXmlMap.keySet()){&#10;            valid= WriterHelper.writeFile(outputDirectory+&quot;/&quot;+key,signedXmlMap.get(key)) &amp;&amp; valid;&#10;        }&#10;        String productCertificate = outputDirectory + &quot;/production_csid.cert&quot;;&#10;        String productionResponse = outputDirectory + &quot;/production_response.json&quot;;&#10;        valid= WriterHelper.writeFile(productionResponse,SecurityUtils.encrypt(JsonUtils.toJson(prodCertificateResponse))) &amp;&amp; valid;&#10;        valid= WriterHelper.writeFile(productCertificate,&#10;                SecurityUtils.encrypt(new String(Base64.getDecoder().decode(prodCertificateResponse.getBinarySecurityToken()),StandardCharsets.UTF_8)))&#10;                &amp;&amp; valid;&#10;        return valid;&#10;    }&#10;&#10;    private boolean loadCsrConfigs() {&#10;        try {&#10;            String timestamp = findLatestTimestamp();&#10;            if (timestamp == null) {&#10;                log.error(&quot;No CSR files found in output directory&quot;);&#10;                return false;&#10;            }&#10;            &#10;            String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;            String csrFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.csr&quot;;&#10;            &#10;            csrEncoded = SecurityUtils.decrypt(ReaderHelper.readFileAsString(csrFile));&#10;            &#10;            String[] serialNumberParts = StringUtils.split(csrConfigDto.getSerialNumber(), &quot;|&quot;);&#10;            if (serialNumberParts.length &gt;= 3) {&#10;                deviceId = serialNumberParts[2];&#10;                taxPayerNumber = serialNumberParts[0];&#10;            } else {&#10;                deviceId = &quot;1&quot;;&#10;                taxPayerNumber = csrConfigDto.getSerialNumber();&#10;            }&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to load CSR configs&quot;,e);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private boolean loadPrivateKey() {&#10;        try {&#10;            String timestamp = findLatestTimestamp();&#10;            if (timestamp == null) {&#10;                log.error(&quot;No private key files found in output directory&quot;);&#10;                return false;&#10;            }&#10;            &#10;            String commonName = extractCommonNameFromDN(csrConfigDto.getSubjectDn());&#10;            String baseFileName = String.format(&quot;%s_%s&quot;, commonName, timestamp);&#10;            String keyFile = outputDirectory + &quot;/&quot; + baseFileName + &quot;.key&quot;;&#10;            &#10;            String privateKeyBase64 = SecurityUtils.decrypt(ReaderHelper.readFileAsString(keyFile));&#10;            byte[] privateKeyBytes = Base64.getDecoder().decode(privateKeyBase64);&#10;            &#10;            try (PEMParser pemParser = new PEMParser(new StringReader(new String(privateKeyBytes, StandardCharsets.UTF_8)))) {&#10;                Object object = pemParser.readObject();&#10;                JcaPEMKeyConverter converter = new JcaPEMKeyConverter();&#10;                &#10;                if (object instanceof PKCS8EncryptedPrivateKeyInfo) {&#10;                    PKCS8EncryptedPrivateKeyInfo encryptedPrivateKeyInfo = (PKCS8EncryptedPrivateKeyInfo) object;&#10;                    InputDecryptorProvider decryptorProvider = new JceOpenSSLPKCS8DecryptorProviderBuilder()&#10;                            .build(csrConfigDto.getKeyPassword().toCharArray());&#10;                    privateKey = converter.getPrivateKey(encryptedPrivateKeyInfo.decryptPrivateKeyInfo(decryptorProvider));&#10;                } else {&#10;                    KeyFactory keyFactory = KeyFactory.getInstance(&quot;RSA&quot;);&#10;                    PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec(privateKeyBytes);&#10;                    privateKey = keyFactory.generatePrivate(keySpec);&#10;                }&#10;            }&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to load private key&quot;,e);&#10;            return false;&#10;        }&#10;        return true;&#10;    }&#10;&#10;    private boolean getProdCertificate() {&#10;        prodCertificateResponse=client.getProdCertificate(complianceCsrResponse,complianceCsrResponse.getRequestID());&#10;        return Objects.nonNull(prodCertificateResponse) &amp;&amp; StringUtils.equalsIgnoreCase(prodCertificateResponse.getDispositionMessage(),&quot;ISSUED&quot;);&#10;    }&#10;&#10;    private boolean complianceInvoices() {&#10;        boolean valid=true;&#10;        int counter=0;&#10;        while (!testQueue.isEmpty()) {&#10;            String xml=testQueue.poll();&#10;            EInvoiceSigningResults signingResults=signingHelper.signEInvoice(xml,privateKey,complianceCertificateStr);&#10;&#10;            String jsonBody= requesterGeneratorHelper.generateEInvoiceRequest(signingResults.getInvoiceHash(),signingResults.getInvoiceUUID(),signingResults.getSignedXml());&#10;            ComplianceInvoiceResponse complianceInvoiceResponse=client.complianceInvoice(complianceCsrResponse,jsonBody);&#10;            if(Objects.isNull(complianceInvoiceResponse) || BooleanUtils.isNotTrue(complianceInvoiceResponse.isValid())){&#10;               log.info(String.format(&quot;Failed to compliance invoice [%s] and error [%s]&quot;,&#10;                       Base64.getEncoder().encodeToString(xml.getBytes(StandardCharsets.UTF_8)),&#10;                       JsonUtils.toJson(complianceInvoiceResponse)));&#10;                valid=false;&#10;            }else{&#10;                String id=&quot;einvoice_test_&quot;+taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+(counter++)+&quot;.xml&quot;;&#10;                signedXmlMap.put(id,signingResults.getSignedXml());&#10;            }&#10;        }&#10;        return valid;&#10;    }&#10;&#10;    private boolean complianceCsr() {&#10;        complianceCsrResponse=client.complianceCsr(otp,csrEncoded);&#10;        complianceCertificateStr=new String(Base64.getDecoder().decode(complianceCsrResponse.getBinarySecurityToken()),StandardCharsets.UTF_8);&#10;        return Objects.nonNull(complianceCsrResponse) &amp;&amp; StringUtils.equalsIgnoreCase(complianceCsrResponse.getDispositionMessage(),&quot;ISSUED&quot;);&#10;    }&#10;&#10;    private boolean enrichTestQueue() {&#10;        boolean valid=false;&#10;        try {&#10;            int counter=0;&#10;            testQueue.add(enrichFile(Objects.requireNonNull(ReaderHelper.readFileFromResource(&quot;samples/b2b_invoice.xml&quot;)),counter++));&#10;            testQueue.add(enrichFile(Objects.requireNonNull(ReaderHelper.readFileFromResource(&quot;samples/b2b_credit.xml&quot;)),counter++));&#10;            valid=true;&#10;        }catch (Exception e){&#10;            log.error(&quot;Failed to enrich test queue&quot;,e);&#10;            return false;&#10;        }&#10;        return valid;&#10;    }&#10;&#10;    private String enrichFile(String file,int counter) {&#10;        String id=taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+counter;&#10;        String orgId=taxPayerNumber+&quot;_&quot;+deviceId+&quot;_&quot;+(counter-1);&#10;        LocalDateTime now = LocalDateTime.now();&#10;        String formattedDate = now.format(formatter);&#10;        String enrichedFile = file.replace(&quot;${ID}&quot;, id);&#10;        enrichedFile = enrichedFile.replace(&quot;${UUID}&quot;, UUID.nameUUIDFromBytes(id.getBytes(StandardCharsets.UTF_8)).toString());&#10;        enrichedFile = enrichedFile.replace(&quot;${ISSUE_DATE}&quot;, formattedDate);&#10;        enrichedFile = enrichedFile.replace(&quot;${ORG_ID}&quot;, orgId);&#10;        enrichedFile = enrichedFile.replace(&quot;${ORG_UUID}&quot;, UUID.nameUUIDFromBytes(orgId.getBytes(StandardCharsets.UTF_8)).toString());&#10;        enrichedFile = enrichedFile.replace(&quot;${VAT_NUMBER}&quot;, taxPayerNumber);&#10;        enrichedFile = enrichedFile.replace(&quot;${TAXPAYER_NAME}&quot;, csrConfigDto.getEnName());&#10;        enrichedFile= enrichedFile.replace(&quot;${DEVICE_ID}&quot;, deviceId);&#10;        return enrichedFile;&#10;    }&#10;    &#10;    private String findLatestTimestamp() {&#10;        try {&#10;            java.io.File dir = new java.io.File(outputDirectory);&#10;            java.io.File[] files = dir.listFiles((d, name) -&gt; name.endsWith(&quot;.csr&quot;) || name.endsWith(&quot;.key&quot;));&#10;            if (files == null || files.length == 0) {&#10;                return null;&#10;            }&#10;            &#10;            String latestTimestamp = null;&#10;            for (java.io.File file : files) {&#10;                String fileName = file.getName();&#10;                String[] parts = fileName.split(&quot;_&quot;);&#10;                if (parts.length &gt;= 2) {&#10;                    String timestamp = parts[parts.length - 1].replace(&quot;.csr&quot;, &quot;&quot;).replace(&quot;.key&quot;, &quot;&quot;);&#10;                    if (latestTimestamp == null || timestamp.compareTo(latestTimestamp) &gt; 0) {&#10;                        latestTimestamp = timestamp;&#10;                    }&#10;                }&#10;            }&#10;            return latestTimestamp;&#10;        } catch (Exception e) {&#10;            log.error(&quot;Failed to find latest timestamp&quot;, e);&#10;            return null;&#10;        }&#10;    }&#10;    &#10;    private String extractCommonNameFromDN(String subjectDn) {&#10;        try {&#10;            String[] parts = subjectDn.split(&quot;,&quot;);&#10;            for (String part : parts) {&#10;                String trimmed = part.trim();&#10;                if (trimmed.toUpperCase().startsWith(&quot;CN=&quot;)) {&#10;                    return trimmed.substring(3).trim().replaceAll(&quot;[^a-zA-Z0-9_-]&quot;, &quot;_&quot;);&#10;                }&#10;            }&#10;            return &quot;CSR&quot;;&#10;        } catch (Exception e) {&#10;            return &quot;CSR&quot;;&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/resolvers/InputResolver.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/resolvers/InputResolver.java" />
              <option name="originalContent" value="package gov.jordan.istd.resolvers;&#10;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.processor.impl.*;&#10;import gov.jordan.istd.processor.impl.DecryptProcess;&#10;import org.apache.log4j.Logger;&#10;&#10;public class InputResolver {&#10;&#10;    private static final Logger logger=Logger.getLogger(&quot;InputResolver&quot;);&#10;&#10;    public static ActionProcessor resolve(String action) {&#10;        switch (action) {&#10;            case &quot;generate-csr-keys&quot;:&#10;                return new CsrKeysProcessor();&#10;            case &quot;onboard&quot;:&#10;                return new OnboardProcessor();&#10;            case &quot;validate&quot;:&#10;                return new InvoiceValidationProcessor();&#10;            case &quot;invoice-sign&quot;:&#10;                return new InvoiceSignProcessor();&#10;            case &quot;generate-qr&quot;:&#10;                return new QrGeneratorProcessor();&#10;            case &quot;submit-clearance&quot;:&#10;                return new InvoiceSubmitProcessor();&#10;            case &quot;submit-report&quot;:&#10;                return new ReportSubmitProcessor();&#10;            case &quot;compliance-invoice&quot;:&#10;                return new ComplianceSubmitProcessor();&#10;            case &quot;decrypt&quot;:&#10;                    return new DecryptProcess();&#10;            default:&#10;                logger.error(&quot;Invalid action, allowed actions are:\n&quot; +&#10;                        &quot;1-generate-csr-keys: to Generate CSR and Key Pairs\n&quot; +&#10;                        &quot;2-onboard: to onboard a generated csr\n&quot; +&#10;                        &quot;3-validate: to validate Invoice\n&quot; +&#10;                        &quot;4-sign: to sign Invoice\n&quot; +&#10;                        &quot;5-generate-qr: to generate QR code\n&quot; +&#10;                        &quot;6-submit-clearance: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;7-submit-report: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;8-compliance-invoice: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;9-decrypt: to decrypt file\n&quot;);&#10;                return null;&#10;        }&#10;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.resolvers;&#10;&#10;import gov.jordan.istd.processor.ActionProcessor;&#10;import gov.jordan.istd.processor.impl.*;&#10;import gov.jordan.istd.processor.impl.DecryptProcess;&#10;import org.apache.log4j.Logger;&#10;&#10;public class InputResolver {&#10;&#10;    private static final Logger logger=Logger.getLogger(&quot;InputResolver&quot;);&#10;&#10;    public static ActionProcessor resolve(String action) {&#10;        switch (action) {&#10;            case &quot;generate-csr-keys&quot;:&#10;                return new CsrKeysProcessor();&#10;            case &quot;onboard&quot;:&#10;                return new OnboardProcessor();&#10;            case &quot;validate&quot;:&#10;                return new InvoiceValidationProcessor();&#10;            case &quot;invoice-sign&quot;:&#10;                return new InvoiceSignProcessor();&#10;            case &quot;generate-qr&quot;:&#10;                return new QrGeneratorProcessor();&#10;            case &quot;submit-clearance&quot;:&#10;                return new InvoiceSubmitProcessor();&#10;            case &quot;submit-report&quot;:&#10;                return new ReportSubmitProcessor();&#10;            case &quot;compliance-invoice&quot;:&#10;                return new ComplianceSubmitProcessor();&#10;            case &quot;decrypt&quot;:&#10;                    return new DecryptProcess();&#10;            default:&#10;                logger.error(&quot;Invalid action, allowed actions are:\n&quot; +&#10;                        &quot;1-generate-csr-keys: to Generate CSR and Key Pairs\n&quot; +&#10;                        &quot;2-onboard: to onboard a generated csr\n&quot; +&#10;                        &quot;3-validate: to validate Invoice\n&quot; +&#10;                        &quot;4-sign: to sign Invoice\n&quot; +&#10;                        &quot;5-generate-qr: to generate QR code\n&quot; +&#10;                        &quot;6-submit-clearance: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;7-submit-report: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;8-compliance-invoice: to submit Invoice to Fotara\n&quot;+&#10;                        &quot;9-decrypt: to decrypt file\n&quot;);&#10;                return null;&#10;        }&#10;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/CmsRequestHelper.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/CmsRequestHelper.java" />
              <option name="originalContent" value="package gov.jordan.istd.utils;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import org.bouncycastle.asn1.*;&#10;import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;&#10;import org.bouncycastle.asn1.x500.X500Name;&#10;import org.bouncycastle.asn1.x509.*;&#10;import org.bouncycastle.operator.ContentSigner;&#10;import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequest;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;&#10;import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;&#10;&#10;import javax.crypto.Cipher;&#10;import javax.crypto.EncryptedPrivateKeyInfo;&#10;import javax.crypto.SecretKey;&#10;import javax.crypto.SecretKeyFactory;&#10;import javax.crypto.spec.PBEKeySpec;&#10;import javax.crypto.spec.PBEParameterSpec;&#10;import java.security.*;&#10;import java.security.spec.PKCS8EncodedKeySpec;&#10;&#10;/**&#10; * Java equivalent of C# CmsRequestHelper class&#10; * Provides CSR generation with RSA keys, Subject Key Identifier, and Certificate Template extensions&#10; */&#10;public class CmsRequestHelper {&#10;&#10;    /**&#10;     * Create CSR with RSA keys and extensions - Java equivalent of C# CreateCsr method&#10;     *&#10;     * @param config Configuration object containing all CSR parameters&#10;     * @return CsrResponseDto containing DER-encoded CSR and encrypted private key&#10;     * @throws Exception if CSR generation fails&#10;     */&#10;    public static CsrResponseDto createCsr(CsrConfigDto config) throws Exception {&#10;        if (config.getPassword() == null || config.getPassword().trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Password must not be null or empty.&quot;);&#10;        }&#10;&#10;        // Generate RSA key pair (equivalent to C# RSA.Create(keySize))&#10;        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);&#10;        keyGen.initialize(config.getKeySize());&#10;        KeyPair keyPair = keyGen.generateKeyPair();&#10;&#10;        // Create subject from DN string (equivalent to C# CertificateRequest)&#10;        X500Name subject = new X500Name(config.getSubjectDn());&#10;&#10;        // Build CSR (equivalent to C# CertificateRequest)&#10;        PKCS10CertificationRequestBuilder builder =&#10;            new JcaPKCS10CertificationRequestBuilder(subject, keyPair.getPublic());&#10;&#10;        // Add extensions&#10;        ExtensionsGenerator extGen = new ExtensionsGenerator();&#10;&#10;        // Subject Key Identifier (SKI) - equivalent to C# SKI creation&#10;        addSubjectKeyIdentifier(extGen, keyPair.getPublic());&#10;&#10;        // Certificate Template Extension (if provided) - Microsoft OID&#10;        if (config.getTemplateOid() != null &amp;&amp; !config.getTemplateOid().isEmpty()) {&#10;            addCertificateTemplateExtension(extGen, config.getTemplateOid(),&#10;                                          config.getMajorVersion(), config.getMinorVersion());&#10;        }&#10;&#10;        // Add extensions to CSR&#10;        Extensions extensions = extGen.generate();&#10;        builder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensions);&#10;&#10;        // Sign the CSR (equivalent to C# CreateSigningRequest with SHA256withRSA and PKCS1 padding)&#10;        ContentSigner signer = new JcaContentSignerBuilder(&quot;SHA256withRSA&quot;).build(keyPair.getPrivate());&#10;        PKCS10CertificationRequest csr = builder.build(signer);&#10;&#10;        // Get CSR DER bytes (equivalent to C# CreateSigningRequest())&#10;        byte[] pkcs10Der = csr.getEncoded();&#10;&#10;        // Encrypt private key (equivalent to C# ExportEncryptedPkcs8PrivateKey)&#10;        byte[] privateKeyBytes = exportEncryptedPkcs8PrivateKey(keyPair.getPrivate(), config.getPassword());&#10;&#10;        return new CsrResponseDto(pkcs10Der, privateKeyBytes);&#10;    }&#10;&#10;    /**&#10;     * Add Subject Key Identifier extension (equivalent to C# SKI creation)&#10;     * Matches the exact C# implementation: SHA1 hash of public key + AsnWriter.WriteOctetString&#10;     */&#10;    private static void addSubjectKeyIdentifier(ExtensionsGenerator extGen, PublicKey publicKey) throws Exception {&#10;        // Get public key bytes (equivalent to C# ExportSubjectPublicKeyInfo)&#10;        byte[] publicKeyBytes = publicKey.getEncoded();&#10;&#10;        // Calculate SHA-1 hash (equivalent to C# SHA1.HashData)&#10;        MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);&#10;        byte[] skiBytes = sha1.digest(publicKeyBytes);&#10;&#10;        // Create SKI extension using DEROctetString (equivalent to C# AsnWriter.WriteOctetString)&#10;        // OID &quot;2.5.29.14&quot; = Subject Key Identifier&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;), false, new DEROctetString(skiBytes));&#10;    }&#10;&#10;    /**&#10;     * Add Certificate Template extension (equivalent to C# BuildCertificateTemplateExtension)&#10;     */&#10;    private static void addCertificateTemplateExtension(ExtensionsGenerator extGen, String oid,&#10;                                                       int majorVersion, int minorVersion) throws Exception {&#10;        // Build template extension (equivalent to C# BuildCertificateTemplateExtension)&#10;        byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;&#10;        // Microsoft Certificate Template OID: 1.3.6.1.4.1.311.21.7&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;1.3.6.1.4.1.311.21.7&quot;),&#10;                           false, new DEROctetString(templateExtension));&#10;    }&#10;&#10;    /**&#10;     * Build Certificate Template extension (equivalent to C# BuildCertificateTemplateExtension method)&#10;     * Exactly matches C#: AsnWriter.PushSequence() -&gt; WriteObjectIdentifier -&gt; WriteInteger -&gt; WriteInteger -&gt; PopSequence&#10;     */&#10;    private static byte[] buildCertificateTemplateExtension(String oid, int majorVersion, int minorVersion) throws Exception {&#10;        ASN1EncodableVector templateVector = new ASN1EncodableVector();&#10;&#10;        // Add template OID (equivalent to C# writer.WriteObjectIdentifier)&#10;        templateVector.add(new ASN1ObjectIdentifier(oid));&#10;&#10;        // Add major version (equivalent to C# writer.WriteInteger)&#10;        templateVector.add(new ASN1Integer(majorVersion));&#10;&#10;        // Add minor version (equivalent to C# writer.WriteInteger)&#10;        templateVector.add(new ASN1Integer(minorVersion));&#10;&#10;        // Create sequence (equivalent to C# PushSequence/PopSequence)&#10;        DERSequence templateSequence = new DERSequence(templateVector);&#10;&#10;        return templateSequence.getEncoded();&#10;    }&#10;&#10;    /**&#10;     * Encrypt private key using PKCS#8 with AES256-CBC (equivalent to C# ExportEncryptedPkcs8PrivateKey)&#10;     * Matches C#: PbeParameters(PbeEncryptionAlgorithm.Aes256Cbc, HashAlgorithmName.SHA256, 100000)&#10;     */&#10;    private static byte[] exportEncryptedPkcs8PrivateKey(PrivateKey privateKey, String password) throws Exception {&#10;        try {&#10;            // Use the Java equivalent of C# PbeParameters(PbeEncryptionAlgorithm.Aes256Cbc, HashAlgorithmName.SHA256, 100000)&#10;            // Java equivalent: PBES2 with HMAC-SHA256 and AES-256-CBC&#10;            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);&#10;&#10;            // Generate salt (16 bytes for AES)&#10;            byte[] salt = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(salt);&#10;&#10;            // Create PBE key spec with 100,000 iterations (matching C#)&#10;            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, 100000, 256); // 256-bit key for AES-256&#10;            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);&#10;&#10;            // Use AES-256-CBC for encryption (matching C# Aes256Cbc)&#10;            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);&#10;&#10;            // Generate IV for CBC mode&#10;            byte[] iv = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(iv);&#10;            javax.crypto.spec.IvParameterSpec ivSpec = new javax.crypto.spec.IvParameterSpec(iv);&#10;&#10;            // Initialize cipher with the derived key&#10;            javax.crypto.spec.SecretKeySpec aesKey = new javax.crypto.spec.SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);&#10;            cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);&#10;&#10;            // Encrypt the private key&#10;            byte[] privateKeyBytes = privateKey.getEncoded();&#10;            byte[] encryptedBytes = cipher.doFinal(privateKeyBytes);&#10;&#10;            // Create PKCS#8 EncryptedPrivateKeyInfo manually using BouncyCastle&#10;            // This matches the C# ExportEncryptedPkcs8PrivateKey format&#10;            org.bouncycastle.asn1.ASN1EncodableVector algorithmVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;&#10;            // PBES2 algorithm identifier&#10;            algorithmVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.13&quot;)); // PBES2&#10;&#10;            // PBES2 parameters&#10;            org.bouncycastle.asn1.ASN1EncodableVector pbes2Params = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;&#10;            // Key derivation function (PBKDF2 with HMAC-SHA256)&#10;            org.bouncycastle.asn1.ASN1EncodableVector kdfVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            kdfVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.12&quot;)); // PBKDF2&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector pbkdf2Params = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.DEROctetString(salt));&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.ASN1Integer(100000)); // iteration count&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.ASN1Integer(32)); // key length (256 bits = 32 bytes)&#10;&#10;            // HMAC-SHA256 identifier&#10;            org.bouncycastle.asn1.ASN1EncodableVector hmacVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            hmacVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.2.9&quot;)); // HMAC-SHA256&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.DERSequence(hmacVector));&#10;&#10;            kdfVector.add(new org.bouncycastle.asn1.DERSequence(pbkdf2Params));&#10;            pbes2Params.add(new org.bouncycastle.asn1.DERSequence(kdfVector));&#10;&#10;            // Encryption scheme (AES-256-CBC)&#10;            org.bouncycastle.asn1.ASN1EncodableVector encSchemeVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            encSchemeVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;2.16.840.1.101.3.4.1.42&quot;)); // AES-256-CBC&#10;            encSchemeVector.add(new org.bouncycastle.asn1.DEROctetString(iv));&#10;            pbes2Params.add(new org.bouncycastle.asn1.DERSequence(encSchemeVector));&#10;&#10;            algorithmVector.add(new org.bouncycastle.asn1.DERSequence(pbes2Params));&#10;&#10;            // Create the complete EncryptedPrivateKeyInfo structure&#10;            org.bouncycastle.asn1.ASN1EncodableVector encPrivKeyVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            encPrivKeyVector.add(new org.bouncycastle.asn1.DERSequence(algorithmVector));&#10;            encPrivKeyVector.add(new org.bouncycastle.asn1.DEROctetString(encryptedBytes));&#10;&#10;            org.bouncycastle.asn1.DERSequence encPrivKeyInfo = new org.bouncycastle.asn1.DERSequence(encPrivKeyVector);&#10;&#10;            return encPrivKeyInfo.getEncoded();&#10;&#10;        } catch (Exception e) {&#10;            throw new Exception(&quot;Failed to encrypt private key: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.utils;&#10;&#10;import gov.jordan.istd.dto.CsrConfigDto;&#10;import gov.jordan.istd.dto.CsrResponseDto;&#10;import org.bouncycastle.asn1.*;&#10;import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;&#10;import org.bouncycastle.asn1.x500.X500Name;&#10;import org.bouncycastle.asn1.x509.*;&#10;import org.bouncycastle.operator.ContentSigner;&#10;import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequest;&#10;import org.bouncycastle.pkcs.PKCS10CertificationRequestBuilder;&#10;import org.bouncycastle.pkcs.jcajce.JcaPKCS10CertificationRequestBuilder;&#10;&#10;import javax.crypto.Cipher;&#10;import javax.crypto.EncryptedPrivateKeyInfo;&#10;import javax.crypto.SecretKey;&#10;import javax.crypto.SecretKeyFactory;&#10;import javax.crypto.spec.PBEKeySpec;&#10;import javax.crypto.spec.PBEParameterSpec;&#10;import java.security.*;&#10;import java.security.spec.PKCS8EncodedKeySpec;&#10;&#10;public class CmsRequestHelper {&#10;&#10;    public static CsrResponseDto createCsr(CsrConfigDto config) throws Exception {&#10;        if (config.getPassword() == null || config.getPassword().trim().isEmpty()) {&#10;            throw new IllegalArgumentException(&quot;Password must not be null or empty.&quot;);&#10;        }&#10;&#10;        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(&quot;RSA&quot;);&#10;        keyGen.initialize(config.getKeySize());&#10;        KeyPair keyPair = keyGen.generateKeyPair();&#10;&#10;        X500Name subject = new X500Name(config.getSubjectDn());&#10;&#10;        PKCS10CertificationRequestBuilder builder =&#10;            new JcaPKCS10CertificationRequestBuilder(subject, keyPair.getPublic());&#10;&#10;        ExtensionsGenerator extGen = new ExtensionsGenerator();&#10;&#10;        addSubjectKeyIdentifier(extGen, keyPair.getPublic());&#10;&#10;        if (config.getTemplateOid() != null &amp;&amp; !config.getTemplateOid().isEmpty()) {&#10;            addCertificateTemplateExtension(extGen, config.getTemplateOid(),&#10;                                          config.getMajorVersion(), config.getMinorVersion());&#10;        }&#10;&#10;        Extensions extensions = extGen.generate();&#10;        builder.addAttribute(PKCSObjectIdentifiers.pkcs_9_at_extensionRequest, extensions);&#10;&#10;        ContentSigner signer = new JcaContentSignerBuilder(&quot;SHA256withRSA&quot;).build(keyPair.getPrivate());&#10;        PKCS10CertificationRequest csr = builder.build(signer);&#10;&#10;        byte[] pkcs10Der = csr.getEncoded();&#10;&#10;        byte[] privateKeyBytes = exportEncryptedPkcs8PrivateKey(keyPair.getPrivate(), config.getPassword());&#10;&#10;        return new CsrResponseDto(pkcs10Der, privateKeyBytes);&#10;    }&#10;&#10;    private static void addSubjectKeyIdentifier(ExtensionsGenerator extGen, PublicKey publicKey) throws Exception {&#10;        byte[] publicKeyBytes = publicKey.getEncoded();&#10;&#10;        MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);&#10;        byte[] skiBytes = sha1.digest(publicKeyBytes);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;2.5.29.14&quot;), false, new DEROctetString(skiBytes));&#10;    }&#10;&#10;    private static void addCertificateTemplateExtension(ExtensionsGenerator extGen, String oid,&#10;                                                       int majorVersion, int minorVersion) throws Exception {&#10;        byte[] templateExtension = buildCertificateTemplateExtension(oid, majorVersion, minorVersion);&#10;&#10;        extGen.addExtension(new ASN1ObjectIdentifier(&quot;1.3.6.1.4.1.311.21.7&quot;),&#10;                           false, new DEROctetString(templateExtension));&#10;    }&#10;&#10;    private static byte[] buildCertificateTemplateExtension(String oid, int majorVersion, int minorVersion) throws Exception {&#10;        ASN1EncodableVector templateVector = new ASN1EncodableVector();&#10;&#10;        templateVector.add(new ASN1ObjectIdentifier(oid));&#10;&#10;        templateVector.add(new ASN1Integer(majorVersion));&#10;&#10;        templateVector.add(new ASN1Integer(minorVersion));&#10;&#10;        DERSequence templateSequence = new DERSequence(templateVector);&#10;&#10;        return templateSequence.getEncoded();&#10;    }&#10;&#10;    private static byte[] exportEncryptedPkcs8PrivateKey(PrivateKey privateKey, String password) throws Exception {&#10;        try {&#10;            SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(&quot;PBKDF2WithHmacSHA256&quot;);&#10;&#10;            byte[] salt = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(salt);&#10;&#10;            PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray(), salt, 100000, 256);&#10;            SecretKey secretKey = secretKeyFactory.generateSecret(pbeKeySpec);&#10;&#10;            Cipher cipher = Cipher.getInstance(&quot;AES/CBC/PKCS5Padding&quot;);&#10;&#10;            byte[] iv = new byte[16];&#10;            SecureRandom.getInstanceStrong().nextBytes(iv);&#10;            javax.crypto.spec.IvParameterSpec ivSpec = new javax.crypto.spec.IvParameterSpec(iv);&#10;&#10;            javax.crypto.spec.SecretKeySpec aesKey = new javax.crypto.spec.SecretKeySpec(secretKey.getEncoded(), &quot;AES&quot;);&#10;            cipher.init(Cipher.ENCRYPT_MODE, aesKey, ivSpec);&#10;&#10;            byte[] privateKeyBytes = privateKey.getEncoded();&#10;            byte[] encryptedBytes = cipher.doFinal(privateKeyBytes);&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector algorithmVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;&#10;            algorithmVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.13&quot;));&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector pbes2Params = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector kdfVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            kdfVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.1.5.12&quot;));&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector pbkdf2Params = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.DEROctetString(salt));&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.ASN1Integer(100000));&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.ASN1Integer(32));&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector hmacVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            hmacVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;1.2.840.113549.2.9&quot;));&#10;            pbkdf2Params.add(new org.bouncycastle.asn1.DERSequence(hmacVector));&#10;&#10;            kdfVector.add(new org.bouncycastle.asn1.DERSequence(pbkdf2Params));&#10;            pbes2Params.add(new org.bouncycastle.asn1.DERSequence(kdfVector));&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector encSchemeVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            encSchemeVector.add(new org.bouncycastle.asn1.ASN1ObjectIdentifier(&quot;2.16.840.1.101.3.4.1.42&quot;));&#10;            encSchemeVector.add(new org.bouncycastle.asn1.DEROctetString(iv));&#10;            pbes2Params.add(new org.bouncycastle.asn1.DERSequence(encSchemeVector));&#10;&#10;            algorithmVector.add(new org.bouncycastle.asn1.DERSequence(pbes2Params));&#10;&#10;            org.bouncycastle.asn1.ASN1EncodableVector encPrivKeyVector = new org.bouncycastle.asn1.ASN1EncodableVector();&#10;            encPrivKeyVector.add(new org.bouncycastle.asn1.DERSequence(algorithmVector));&#10;            encPrivKeyVector.add(new org.bouncycastle.asn1.DEROctetString(encryptedBytes));&#10;&#10;            org.bouncycastle.asn1.DERSequence encPrivKeyInfo = new org.bouncycastle.asn1.DERSequence(encPrivKeyVector);&#10;&#10;            return encPrivKeyInfo.getEncoded();&#10;&#10;        } catch (Exception e) {&#10;            throw new Exception(&quot;Failed to encrypt private key: &quot; + e.getMessage(), e);&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/OtherFunctions.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/OtherFunctions.java" />
              <option name="updatedContent" value="package gov.jordan.istd.utils;&#10;&#10;import java.util.Base64;&#10;&#10;/**&#10; * Java equivalent of C# OtherFunctions class&#10; * Provides utility methods for PEM conversion and CSR string cleaning&#10; */&#10;public class OtherFunctions {&#10;    &#10;    /**&#10;     * Convert private key bytes to PEM format (equivalent to C# ConvertPrivateKeyBytesToPem)&#10;     */&#10;    public static String convertPrivateKeyBytesToPem(byte[] privateKeyBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(privateKeyBytes), 64));&#10;        builder.append(&quot;\n-----END ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;    /**&#10;     * Convert certificate bytes to PEM format (equivalent to C# ConvertCertificateBytesToPem)&#10;     */&#10;    public static String convertCertificateBytesToPem(byte[] certBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN CERTIFICATE-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(certBytes), 64));&#10;        builder.append(&quot;\n-----END CERTIFICATE-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;    &#10;    /**&#10;     * Clean CSR string by removing PEM headers and whitespace (equivalent to C# CleanCsrString)&#10;     */&#10;    public static String cleanCsrString(String rawCsr) {&#10;        if (rawCsr == null || rawCsr.trim().isEmpty()) {&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        return rawCsr&#10;            .replaceAll(&quot;(?i)-----BEGIN CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replaceAll(&quot;(?i)-----END CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replace(&quot;\r&quot;, &quot;&quot;)&#10;            .replace(&quot;\n&quot;, &quot;&quot;)&#10;            .replace(&quot;\t&quot;, &quot;&quot;)&#10;            .trim();&#10;    }&#10;    &#10;    /**&#10;     * Insert line breaks every specified number of characters (equivalent to C# Base64FormattingOptions.InsertLineBreaks)&#10;     */&#10;    private static String insertLineBreaks(String input, int lineLength) {&#10;        StringBuilder result = new StringBuilder();&#10;        for (int i = 0; i &lt; input.length(); i += lineLength) {&#10;            result.append(input, i, Math.min(i + lineLength, input.length()));&#10;            if (i + lineLength &lt; input.length()) {&#10;                result.append(&quot;\n&quot;);&#10;            }&#10;        }&#10;        return result.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/pemConversionAndStringUtils.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/gov/jordan/istd/utils/pemConversionAndStringUtils.java" />
              <option name="originalContent" value="package gov.jordan.istd.utils;&#10;&#10;import java.util.Base64;&#10;&#10;/**&#10; * Java equivalent of C# OtherFunctions class&#10; * Provides utility methods for PEM conversion and CSR string cleaning&#10; */&#10;public class pemConversionAndStringUtils {&#10;&#10;    /**&#10;     * Convert private key bytes to PEM format (equivalent to C# ConvertPrivateKeyBytesToPem)&#10;     */&#10;    public static String convertPrivateKeyBytesToPem(byte[] privateKeyBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(privateKeyBytes), 64));&#10;        builder.append(&quot;\n-----END ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;    /**&#10;     * Convert certificate bytes to PEM format (equivalent to C# ConvertCertificateBytesToPem)&#10;     */&#10;    public static String convertCertificateBytesToPem(byte[] certBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN CERTIFICATE-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(certBytes), 64));&#10;        builder.append(&quot;\n-----END CERTIFICATE-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;    /**&#10;     * Clean CSR string by removing PEM headers and whitespace (equivalent to C# CleanCsrString)&#10;     */&#10;    public static String cleanCsrString(String rawCsr) {&#10;        if (rawCsr == null || rawCsr.trim().isEmpty()) {&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        return rawCsr&#10;            .replaceAll(&quot;(?i)-----BEGIN CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replaceAll(&quot;(?i)-----END CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replace(&quot;\r&quot;, &quot;&quot;)&#10;            .replace(&quot;\n&quot;, &quot;&quot;)&#10;            .replace(&quot;\t&quot;, &quot;&quot;)&#10;            .trim();&#10;    }&#10;&#10;    /**&#10;     * Insert line breaks every specified number of characters (equivalent to C# Base64FormattingOptions.InsertLineBreaks)&#10;     */&#10;    private static String insertLineBreaks(String input, int lineLength) {&#10;        StringBuilder result = new StringBuilder();&#10;        for (int i = 0; i &lt; input.length(); i += lineLength) {&#10;            result.append(input, i, Math.min(i + lineLength, input.length()));&#10;            if (i + lineLength &lt; input.length()) {&#10;                result.append(&quot;\n&quot;);&#10;            }&#10;        }&#10;        return result.toString();&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package gov.jordan.istd.utils;&#10;&#10;import java.util.Base64;&#10;&#10;/**&#10; * Java equivalent of C# OtherFunctions class&#10; * Provides utility methods for PEM conversion and CSR string cleaning&#10; */&#10;public class pemConversionAndStringUtils {&#10;&#10;    /**&#10;     * Convert private key bytes to PEM format (equivalent to C# ConvertPrivateKeyBytesToPem)&#10;     */&#10;    public static String convertPrivateKeyBytesToPem(byte[] privateKeyBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(privateKeyBytes), 64));&#10;        builder.append(&quot;\n-----END ENCRYPTED PRIVATE KEY-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;    /**&#10;     * Convert certificate bytes to PEM format (equivalent to C# ConvertCertificateBytesToPem)&#10;     */&#10;    public static String convertCertificateBytesToPem(byte[] certBytes) {&#10;        StringBuilder builder = new StringBuilder();&#10;        builder.append(&quot;-----BEGIN CERTIFICATE-----\n&quot;);&#10;        builder.append(insertLineBreaks(Base64.getEncoder().encodeToString(certBytes), 64));&#10;        builder.append(&quot;\n-----END CERTIFICATE-----\n&quot;);&#10;        return builder.toString();&#10;    }&#10;&#10;    /**&#10;     * Clean CSR string by removing PEM headers and whitespace (equivalent to C# CleanCsrString)&#10;     */&#10;    public static String cleanCsrString(String rawCsr) {&#10;        if (rawCsr == null || rawCsr.trim().isEmpty()) {&#10;            return &quot;&quot;;&#10;        }&#10;&#10;        return rawCsr&#10;            .replaceAll(&quot;(?i)-----BEGIN CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replaceAll(&quot;(?i)-----END CERTIFICATE REQUEST-----&quot;, &quot;&quot;)&#10;            .replace(&quot;\r&quot;, &quot;&quot;)&#10;            .replace(&quot;\n&quot;, &quot;&quot;)&#10;            .replace(&quot;\t&quot;, &quot;&quot;)&#10;            .trim();&#10;    }&#10;&#10;    /**&#10;     * Insert line breaks every specified number of characters (equivalent to C# Base64FormattingOptions.InsertLineBreaks)&#10;     */&#10;    private static String insertLineBreaks(String input, int lineLength) {&#10;        StringBuilder result = new StringBuilder();&#10;        for (int i = 0; i &lt; input.length(); i += lineLength) {&#10;            result.append(input, i, Math.min(i + lineLength, input.length()));&#10;            if (i + lineLength &lt; input.length()) {&#10;                result.append(&quot;\n&quot;);&#10;            }&#10;        }&#10;        return result.toString();&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>